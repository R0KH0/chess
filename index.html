<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tournament Bracket Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: white;
            overflow-x: auto; /* Allow horizontal scroll for large brackets */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            height: 10px;
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #64748b; 
        }

        /* Bracket Logic Styles */
        .bracket-container {
            display: flex;
            flex-direction: row;
            padding: 40px;
            min-width: 1600px; /* Increased for 5 columns */
        }

        .round {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            width: 250px;
            margin-right: 40px;
            position: relative;
        }

        .match {
            background-color: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 8px; 
            margin: 6px 0; 
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
        }
        
        /* Specific styling for matches that are just Byes */
        .match.bye-match {
            background-color: transparent;
            border: 1px dashed #334155;
            opacity: 0.7;
        }
        .match.bye-match:hover {
            border-color: #475569;
            opacity: 1;
        }

        .match:hover {
            border-color: #64748b;
        }

        .team {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px; /* Compact padding */
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 2px;
        }

        .team:last-child {
            margin-bottom: 0;
        }

        .team:hover {
            background-color: #334155;
        }

        .team input {
            background: transparent;
            border: none;
            color: #e2e8f0;
            width: 100%;
            font-size: 0.85rem; /* Slightly smaller font for density */
            outline: none;
            font-weight: 500;
        }

        .team input::placeholder {
            color: #64748b;
        }

        .team input:focus {
            border-bottom: 1px solid #3b82f6;
        }

        .winner-btn {
            opacity: 0;
            color: #4ade80;
            margin-left: 8px;
            transition: opacity 0.2s;
        }

        .team:hover .winner-btn {
            opacity: 1;
        }

        .team.won {
            background-color: rgba(34, 197, 94, 0.2);
            border-left: 3px solid #4ade80;
        }
        
        .team.won input {
            color: #4ade80;
            font-weight: 700;
        }
        
        /* Styles for disabled/bye inputs */
        .team.bye-slot {
            pointer-events: none;
        }
        .team.bye-slot input {
            color: #64748b;
            font-style: italic;
            font-size: 0.75rem;
        }

        /* Connector Lines */
        .connector {
            position: absolute;
            right: -40px;
            width: 20px;
            border-right: 2px solid #475569;
        }
        
        /* Logic to draw lines between matches */
        .round:not(:last-child) .match::after {
            content: '';
            position: absolute;
            right: -20px;
            top: 50%;
            width: 20px;
            height: 2px;
            background-color: #475569;
        }

        .round:not(:first-child) .match::before {
            content: '';
            position: absolute;
            left: -20px;
            top: 50%;
            width: 20px;
            height: 2px;
            background-color: #475569;
        }

        /* Vertical connectors for pairing */
        .match-pair-connector {
            position: absolute;
            right: -20px;
            width: 2px;
            background-color: #475569;
        }

        /* Champion Section */
        .champion-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            margin-left: 20px;
        }

        .trophy {
            font-size: 3rem;
            color: #fbbf24;
            margin-bottom: 10px;
            filter: drop-shadow(0 0 10px rgba(251, 191, 36, 0.5));
        }

        .reset-btn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 50;
        }
    </style>
</head>
<body class="antialiased selection:bg-blue-500 selection:text-white">

    <!-- Header -->
    <div class="fixed top-0 left-0 w-full bg-slate-900/90 backdrop-blur-md border-b border-slate-700 z-40 px-6 py-4 flex justify-between items-center">
        <div>
            <h1 class="text-xl font-bold text-blue-400"><i class="fas fa-trophy mr-2"></i>ARK-X Chess Tournament (FEZ)</h1>
        </div>
        <div class="text-xs text-slate-500 hidden sm:block">
            <span id="status-msg">Auto-saving enabled</span>
        </div>
    </div>

    <!-- Main Bracket Area -->
    <div class="pt-24 pb-20 overflow-x-auto min-h-screen flex items-center">
        <div id="bracket-root" class="bracket-container">
            <!-- Bracket will be injected here by JS -->
        </div>
    </div>

    <!-- Reset Button -->
    <button onclick="resetTournament()" class="reset-btn bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-full shadow-lg transition transform hover:scale-105 flex items-center gap-2">
        <i class="fas fa-trash-alt"></i> Reset Bracket
    </button>

    <script>
        // Configuration: 20 Teams
        // Round 1 (32 slots): 12 Byes, 4 Matches (8 Teams playing)
        // Round 2 (16 slots): 16 Teams (12 Byes + 4 Winners)
        
        // Key for local storage - changed to v2 to avoid conflicts with previous versions
        const STORAGE_KEY = 'tournament_bracket_20team_v2';
        
        // Initial state structure
        function createDefaultData() {
            // We need 16 matches in Round 1.
            // 20 Teams total.
            // 32 (Slots) - 20 (Teams) = 12 Byes.
            // Teams playing in R1 = 20 - 12 = 8 Teams.
            // Matches playing in R1 = 8 / 2 = 4 Matches.
            // Matches with Byes in R1 = 12 Matches.
            
            // Logic: Evenly distribute the 4 "Play-in" matches across the 16 slots
            // Indices: 0, 4, 8, 12 will be Real Matches. Rest are Byes.
            const realMatchIndices = [0, 4, 8, 12];
            
            let teamCounter = 1;

            const round1Matches = Array.from({length: 16}, (_, i) => {
                const isRealMatch = realMatchIndices.includes(i);
                
                if (isRealMatch) {
                    // This is a match between two teams
                    return {
                        id: `r1-m${i}`,
                        p1: `Team ${teamCounter++}`,
                        p2: `Team ${teamCounter++}`,
                        winner: null,
                        isByeMatch: false
                    };
                } else {
                    // This is a BYE match (One team vs BYE)
                    // The "Winner" is pre-set effectively, but we handle it in init
                    return {
                        id: `r1-m${i}`,
                        p1: `Team ${teamCounter++}`,
                        p2: "BYE",
                        winner: 1, // Auto-advance player 1
                        isByeMatch: true
                    };
                }
            });

            // Round 2 needs to know about the auto-winners from R1
            const round2Matches = Array.from({length: 8}, (_, i) => {
                // Determine source matches from R1
                const m1Index = i * 2;
                const m2Index = i * 2 + 1;
                
                const m1 = round1Matches[m1Index];
                const m2 = round1Matches[m2Index];
                
                // Pre-fill if R1 was a bye match
                const p1Val = (m1.isByeMatch) ? m1.p1 : null;
                const p2Val = (m2.isByeMatch) ? m2.p1 : null;
                
                return { 
                    id: `r2-m${i}`, 
                    p1: p1Val, 
                    p2: p2Val, 
                    winner: null 
                };
            });

            return {
                rounds: [
                    { id: 0, matches: round1Matches },
                    { id: 1, matches: round2Matches },
                    // Standard cleanup for rest
                    { id: 2, matches: Array.from({length: 4}, (_, i) => ({ id: `r3-m${i}`, p1: null, p2: null, winner: null })) },
                    { id: 3, matches: Array.from({length: 2}, (_, i) => ({ id: `r4-m${i}`, p1: null, p2: null, winner: null })) },
                    { id: 4, matches: Array.from({length: 1}, (_, i) => ({ id: `r5-m${i}`, p1: null, p2: null, winner: null })) }
                ],
                champion: null
            };
        }

        let bracketData = createDefaultData();

        // --- Core Logic ---

        function init() {
            loadState();
            renderBracket();
        }

        function saveState() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(bracketData));
            const msg = document.getElementById('status-msg');
            msg.textContent = "Saved to local storage";
            msg.style.color = "#4ade80";
            setTimeout(() => {
                msg.textContent = "Auto-saving enabled";
                msg.style.color = "#64748b";
            }, 1000);
        }

        function loadState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                bracketData = JSON.parse(saved);
            } else {
                // First load? Ensure default data is fresh and logic runs
                bracketData = createDefaultData(); 
                saveState();
            }
        }

        function resetTournament() {
            if(confirm("Are you sure you want to reset the tournament to 20 Teams?")) {
                bracketData = createDefaultData();
                saveState();
                renderBracket();
            }
        }

        function updateName(roundIndex, matchIndex, playerSlot, newName) {
            const currentRound = bracketData.rounds[roundIndex];
            const match = currentRound.matches[matchIndex];
            
            if (playerSlot === 1) match.p1 = newName;
            else match.p2 = newName;
            
            // Automatic propagation logic
            // If this is a BYE match (Round 1 only), updating the P1 name should instantly update Round 2
            if (roundIndex === 0 && match.isByeMatch && playerSlot === 1) {
                // Force update next round without needing a winner click (since it's auto-won)
                updateNextRoundSlot(roundIndex, matchIndex, newName);
            }
            
            // Standard propagation if winner is selected
            if (match.winner === 1 && playerSlot === 1) advanceWinner(roundIndex, matchIndex, 1, false);
            if (match.winner === 2 && playerSlot === 2) advanceWinner(roundIndex, matchIndex, 2, false);

            saveState();
        }

        function advanceWinner(roundIndex, matchIndex, playerSlot, toggle = true) {
            const currentRound = bracketData.rounds[roundIndex];
            const match = currentRound.matches[matchIndex];
            
            // Prevent interaction with Bye slots in Round 1
            if (roundIndex === 0 && match.isByeMatch) return;

            const winnerName = playerSlot === 1 ? match.p1 : match.p2;
            if (!winnerName) return; 

            // Logic to toggle
            if (toggle && match.winner === playerSlot) {
                match.winner = null;
                updateNextRoundSlot(roundIndex, matchIndex, null);
                saveState();
                renderBracket();
                return;
            }

            match.winner = playerSlot;

            if (roundIndex === bracketData.rounds.length - 1) {
                bracketData.champion = winnerName;
            } else {
                updateNextRoundSlot(roundIndex, matchIndex, winnerName);
            }

            saveState();
            renderBracket();
        }

        function updateNextRoundSlot(currentRoundIndex, currentMatchIndex, name) {
            if (currentRoundIndex >= bracketData.rounds.length - 1) return;

            const nextRoundIndex = currentRoundIndex + 1;
            const nextMatchIndex = Math.floor(currentMatchIndex / 2);
            const nextPlayerSlot = (currentMatchIndex % 2 === 0) ? 1 : 2; 

            const nextMatch = bracketData.rounds[nextRoundIndex].matches[nextMatchIndex];
            
            if (nextPlayerSlot === 1) nextMatch.p1 = name;
            else nextMatch.p2 = name;

            // If the match in the NEXT round already has a winner, reset it to avoid stale data
            // UNLESS it's an auto-bye match, but R2+ don't have auto-byes in this setup
            if (nextMatch.winner) {
                nextMatch.winner = null;
                updateNextRoundSlot(nextRoundIndex, nextMatchIndex, null); 
            }
        }

        // --- Rendering ---

        function renderBracket() {
            const container = document.getElementById('bracket-root');
            container.innerHTML = '';

            bracketData.rounds.forEach((round, rIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round';
                
                // Round Header
                const header = document.createElement('div');
                header.className = "text-center text-slate-500 text-sm font-bold mb-4 uppercase tracking-wider absolute -top-8 w-full";
                
                if(rIndex === 0) header.innerText = "Round 1 (Play-ins)";
                else if(rIndex === 1) header.innerText = "Round 2 (16)";
                else if(rIndex === 2) header.innerText = "Quarter Finals";
                else if(rIndex === 3) header.innerText = "Semi Finals";
                else if(rIndex === 4) header.innerText = "Finals";
                
                roundDiv.appendChild(header);

                round.matches.forEach((match, mIndex) => {
                    const matchDiv = document.createElement('div');
                    // Add special class for Bye matches in Round 1
                    const isByeMatch = (rIndex === 0 && match.isByeMatch);
                    matchDiv.className = `match ${isByeMatch ? 'bye-match' : ''}`;

                    if (isByeMatch) {
                        // Render Simplified View for Bye Match
                        // Just Player 1 input, showing they qualify automatically
                        matchDiv.appendChild(createTeamElement(rIndex, mIndex, 1, match.p1, true, false)); // True for isWinner (visual green), false for showBtn
                        
                        // Fake P2 slot saying "Bye"
                        const byeDiv = document.createElement('div');
                        byeDiv.className = 'team bye-slot';
                        byeDiv.innerHTML = `<span class="text-xs text-slate-500 italic px-2">Direct Entry to Round 2</span>`;
                        matchDiv.appendChild(byeDiv);
                    } else {
                        // Standard Match
                        matchDiv.appendChild(createTeamElement(rIndex, mIndex, 1, match.p1, match.winner === 1, true));
                        matchDiv.appendChild(createTeamElement(rIndex, mIndex, 2, match.p2, match.winner === 2, true));
                    }

                    roundDiv.appendChild(matchDiv);
                });

                container.appendChild(roundDiv);
            });

            // Render Champion Column
            const champDiv = document.createElement('div');
            champDiv.className = 'champion-container';
            champDiv.innerHTML = `
                <i class="fas fa-crown trophy"></i>
                <div class="text-slate-400 text-sm uppercase tracking-widest mb-2">Champion</div>
                <div class="bg-gradient-to-r from-yellow-600 to-yellow-400 text-slate-900 font-bold px-6 py-3 rounded-lg shadow-lg text-xl min-w-[150px] text-center">
                    ${bracketData.champion || '?'}
                </div>
            `;
            container.appendChild(champDiv);
        }

        function createTeamElement(rIndex, mIndex, slot, name, isWinner, showBtn) {
            const div = document.createElement('div');
            div.className = `team ${isWinner ? 'won' : ''}`;
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = name || '';
            input.placeholder = (rIndex === 0 && name && name.includes('Team')) ? name : "Waiting...";
            
            // If it's a generated "Waiting..." or empty slot in later rounds, don't allow typing unless populated
            // But we allow full editing for flexibility
            input.addEventListener('input', (e) => updateName(rIndex, mIndex, slot, e.target.value));
            
            div.appendChild(input);

            if (showBtn && name) {
                const btn = document.createElement('button');
                btn.className = 'winner-btn';
                btn.innerHTML = '<i class="fas fa-check-circle"></i>';
                btn.title = "Mark as Winner";
                btn.onclick = () => advanceWinner(rIndex, mIndex, slot);
                div.appendChild(btn);
            }

            return div;
        }

        // Start
        init();

    </script>
</body>
</html>